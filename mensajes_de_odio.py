# -*- coding: utf-8 -*-
##"""mensajes de odio.ipynb

#Automatically generated by Colab.

#Original file is located at
    #https://colab.research.google.com/drive/1Y9bA6Ua3z1JwTxSo5DfUOZRe9XvmZJSs

# Proyecto 2: Clasificación de Texto

#En la actualidad, las redes sociales desempeñan un papel fundamental en nuestras interacciones sociales y en cómo nos relacionamos. Sin embargo, un efecto secundario de esto es la propagación de ideologías, opiniones e información en general.

#Según un artículo de la BBC que cita un estudio, durante la pandemia(2019-2021) y en años posteriores, los discursos de odio en redes sociales aumentaron un 20\%, al igual que el acoso cibernético. Estos efectos se ven exacerbados durante eventos importantes.

#Nuestro objetivo es desarrollar un sistema capaz de detectar mensajes de odio y poder clasificarlo en diversas categorías.

## **1.-** Adquisición de los Datos

#Para resolver este problema nos propusimos aplicar un modelo de clasificación multiclase de texto para 6 categorías:


#1.   No Odio: mensajes que no son de odio
#2.   Sexismo: mensajes de odio basados en discriminación sexual
#3.   Racismo: mensajes de odio en base a la raza de las personas
#4.   Religion: mensajes de odio en base a la religion que profesan
#5.   Orientacion: mensajes de odio en base a la orientación sexual de las personas
#6.   Origen: mensajes de odio en base al lugar de donde provienen las personas (xenofobia)

#Ya una vez que definimos el problema nos debemos enfrentar a la búsqueda de los datos:

#Para poder encontrar los datos nos enfrentamos a varias situaciones, la primera fue intentar encontrar datos en español, puesto que la información que contenga esta información está muy limitada a tener pocos datos, y en su mayoría sólo estaban etiquetadas en si eran de odio o no, es decir, una clasificación binaria. Pero nuestro propósito es realiar una clasificación multiclase para 6 categorías, por lo que intentamos hablar con alguna IA de procesamiento de lenguaje para que nos dé información, pero estas se rechazan a darnos mensajes de odio ya que estas están programadas para evitar este tipo de comentarios.

#Pero BING nos ofreció bases de datos en inglés que tienen muchos datos, así que decidimos tomar varias bases de datos de diversas categorías y juntarlas todas en una misma base de datos.

#Algunas de las bases que tomamos son:


#*   https://www.kaggle.com/competitions/jigsaw-unintended-bias-in-toxicity-classification/data?select=train.csv
#*   https://www.kaggle.com/datasets/victorcallejasf/multimodal-hate-speech/data   
#*   https://www.kaggle.com/datasets/rahulgoel1106/xenophobia-on-twitter-during-covid19/data
#*   https://www.kaggle.com/datasets/gbiamgaurav/cyberbullying-detection
#*   https://www.kaggle.com/datasets/smmmmmmmmmmmm/twitter-data
#*   https://www.kaggle.com/datasets/staru09/twitter-parsed-full-data

#Después de nuestra mezcla de datos, conseguimos tener la siguiente cantidad de datos para las diversas categorías:

#![WhatsApp Image 2024-04-17 at 1.20.19 PM.jpeg](data:image/jpeg;base64,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)

#Tuvimos los siguientes registros de mensajes de odio en las categorías:

#18K para Género

#23K para No Odio

#11K para Origen

#18K para Racismo

#16K para Religion

#22K para Sexismo

#Como podemos ver, los datos están un poco desbalanceados, teniendo 22K datos para la categoría más repetida y 11K para la categoría con menos imputaciones, esto puede causar algunos problemas con el modelo a la hora de dividir en train y test.

#Debido a esto nosotros tomamos la decisión de tomar 10,000 datos de cada una de las categorías, para tener una base balanceada y aún mantener una gran cantidad considerable de datos que nos podrán ayudar a hacer un buen modelo.

#A su vez, la decisión de tomar sólo 10,000 datos de cada una es porque nuestra base de datos está en inglés, y nosotros necesitamos la base en español, es por esto que tomamos la decisión de traducir la base de datos usando la función Translator de la paquetería gtrans, este código viene en el siguiente bloque, está comentado de forma que no va a compilarse, y no es necesario, puesto que la base ya traducida también fue colocada debajo, de esta forma se pueden evitar el tener que traducirla, puesto que esta traducción tarda al rededor de 2 horas

##### Taducción de la Base de Datos
#"""

#convertir nuestro df mensajeodio.csv a UTF-8
#
# !iconv -f ISO-8859-1 -t UTF-8 /content/drive/MyDrive/CC/Mensajes\ de\ odio/mensajeodio.csv > /content/drive/MyDrive/CC/Mensajes\ de\ odio/mensajeodioUTF8.csv
#

#show mensajedeodioUTF8.csv

#from google.colab import files

# Download the file from Google Drive
# files.download("/content/drive/MyDrive/CC/Mensajes de odio/mensajeodioUTF8.csv")

# import pandas as pd

# df = pd.read_csv("/content/drive/MyDrive/CC/Mensajes de odio/mensajeodioUTF8.csv")

# Print the first few rows of the DataFrame
# print(df.head())

# df.info()

# !pip install googletrans==3.1.0a0

# import googletrans
# from googletrans import Translator
# import pandas as pd

# translator = Translator
# df_en = pd.read_csv("/content/drive/MyDrive/CC/Mensajes de odio/mensajeodioUTF8.csv")

# df_en.head()

# !pip install googletrans
# from googletrans import Translator

## Create a translator object.
# translator = Translator()

## Rename columns in df_es using translated column names.
# df_es = df_en.copy()
# df_es.rename(columns=lambda x: translator.translate(x, dest='es').text, inplace=True)

## Print the columns of df_es.
# df_es.columns

# df_es.head()

# !pip install googletrans
# from googletrans import Translator

# Create a translator object.
# translator = Translator()

# Translate the entire df_en DataFrame to Spanish.
# df_es = df_en.copy()
## for column in df_es.columns:
#df_es[column] = df_es[column].apply(lambda x: translator.translate(x, dest='es').text)

# Print the translated DataFrame.
# df_es

# df_es.to_csv('df_es.csv', index=False)

# from google.colab import files

## Save the translated DataFrame to a CSV file.
#df_es.to_csv('df_es.csv', index=False)

## Download the CSV file.
# files.download('df_es.csv')

##"""## **2.-** Preprocesamiento de Datos

##En esta parte se encuentra ya importada la base de datos en español, después de modificar algunos datos que no leyeron bien los acentos, esto lo hicimos con OpenRefine, por lo que los pasos no se encuentran aquí.
#"""

#tenemos que importar la librería chardet, ya qye esta nos permite conocer que tipo de codificación tienen los datos, si UTF-8 o de cual se trata
#!pip install chardet

#para acceder a la base en drive
#from google.colab import drive
#drive.mount('/content/drive') (SOLO PARA EL COLAB)

#pandas y chardet para leer la base y la codificación
import pandas as pd #(YA ESTA INSTALADO)
import chardet #(YA ESTA INSTALADO)

with open("CSV/odioesp.csv", "rb") as f:
    encoding = chardet.detect(f.read())["encoding"]
    #verificamos que codificación tiene la base para poder cargarla exitosamente :D

df = pd.read_csv("CSV/odioesp.csv", encoding=encoding)
#importar la base de datos

df = df.drop(columns=['Unnamed: 2'])

df.head()
#ver los primeros registros

df.info()
#ver la cantidad de datos que tenemos

#"""Podemos observar que el DF detecta 60,000 entradas, puesto que nosotros tomamos 10,000 imputaciones de cada una de las 6 características, pero al manipular los datos en OpenRefine nos dimos cuenta que la base de datos tiene muchos duplicados en algunas categorías, así que las vamos a retirar, ya que se puede sesgar la información si la mayoría de las repeticiones entran en la división de train, y en caso de que varias caigan en la categoría de test, vamos a tener un sobreajuste de los datos, ya que estos se van a poder clasificar muy bien, pero puede tener problemas con clasificar los demás, así que debemos quitarlos para evitar problemas, una vez retiradas las duplicaciones obtenemos la siguiente cantidad de datos:"""

#quitar duplciados en la columna text
df.drop_duplicates(subset="text", inplace=True)

#quitar los posibles valores na

df = df.dropna(subset=['text'])

df.info()

#"""Ya sin duplicados y sin posibles valores NA, tenemos 49378 entradas de datos, divididos en la siguiente cantidad para cada categoría:


#"""

import matplotlib.pyplot as plt #(YA INSTALADO)

#cantidad de registros para cada característica que tenemos
conteo_caracteristicas = df['target'].value_counts()

#grafica
plt.figure(figsize=(10, 6))
conteo_caracteristicas.plot(kind='bar', color='skyblue')
plt.title('Registros por Característica de Odio')
plt.xlabel('Característica')
plt.ylabel('Registros')
plt.xticks(rotation=45)
plt.tight_layout()
plt.savefig("images/Grafica1.png")

#"""Una vez sin duplicados podemos ver que tenemos aproximadamente 10K entradas de datos para cada categoría, excepto para la de Orientación y Sexismo, como la diferencia entre las categorías no es tan grande como en otros casos, mantendremos así los datos para hacer el modelo.

### Extracción de características:

#Primero vamos a pasar todo el texto a minúsclas, puesto que ya quitamos acentos y símbolos que no pertenecen al idioma inglés, los cuales podrían haber causado algunos problemas en el dataframe al momento de hacer el modelo.
#"""

df['text'] = df['text'].str.lower()

#"""Ahora, en nuestro caso nuetra columna de texto algunas veces tiene @user, ya que es un retwit o respuesta a alguna persona, por lo que quitaremos estos caracteres."""

import re #(regex instalado)

#funcion que detecta y elimina en el texto cualquier @user, es decir, detecta el símbolo @, y se dedica a eliminar el texto hasta encontrar el primer espacio
#asi si se encuentra algo como @bebexitomoxito hola bb se quedará únicamente el hola bb
def remove_user_mentions(text):
    return re.sub(r'@\S+', '', text)

#Aplicar la función a la columna 'text'
df['text'] = df['text'].apply(remove_user_mentions)

#"""Parte de manejar estos datos es también quitar los números, puesto que no suelen aportar mucho a la información en realidad, los números pueden hacer referencias a fechas, pero no por esto indica que una fecha indique que todo ese año es por racismo o así, por lo que también quitaremos los números"""

#función para quitar los números y remplazarlos por nada
def remove_numbers(text):
    return re.sub(r'\d+', '', text)

#aplicar la función a la columna
df['text'] = df['text'].apply(remove_numbers)
print(df['text'])

#"""Hay otras cosas varias que debemos hacer, para evitar tener que estar haciendo celdas y celdas de código, juntaremos todo en una función clave que hará varias cosas:

#.- Tikenización: esto dividirá el texto en palabras individuales, para así analizar cada palabra

#.- Eliminar palabras de conjunción: son las palabras como "la, el, tu, de, y, o" que son palabras que en realidad no aportan mucho significado al texto, puesto que nos interesa más identificar palabras claves en los textos de odio.

#.- Parte de la limpieza de texto también es eliminar signos de puntuación, como símbolos de pregunta, de admiración, puntos, comas, doble punto, etc. Ya que si tenemos muchas comas en la categoría de Genero, por ejemplo, el programa pensará que este símbolo de puntuación es una palabra de odio, por lo que no es útil.

#.- Lematizar las palabras, esto lo que ahce es reducir las palabras a su forma base, para determinar la forma de una palabra, proceso complicado de entender y explicar

#.- Por último, vamos a convertir el texto en vectores numéricos, ya que los algoritmos de aprendizaje, y sobre todo una computadora, únicamente entiende números, nosotros usaremos TF-IDF, técnica que se encarga de ponderar la importancia de una palabra en un documento dentro de una colección de documentos, lo que nos permite representar la relevacnia de un término en un documento. Se reconoce como un término importante si aparece con frecuencia en el documento, y es menos importante si aparece en muchos otros documentos.

#Ejemplo:
#Veamos un ejemplo para entenderlo mejor:

#"El gato está sobre la mesa"

#"La mesa está en la cocina"

#"El perro está bajo la mesa"

#Calcularemos el TF-IDF para la palabra "mesa" en cada uno de los documentos.

#Para el texto 1:

#TF("mesa", Documento 1) = 1 (aparece una vez)

#IDF("mesa") = log(3 / 3) = log(1) = 0

#TF-IDF("mesa", Documento 1) = 1 * 0 = 0

#Para el texto 2:

#TF("mesa", Documento 2) = 1 (aparece una vez)

#IDF("mesa") = log(3 / 3) = log(1) = 0

#TF-IDF("mesa", Documento 2) = 1 * 0 = 0

#Para el texto 3:

#TF("mesa", Documento 3) = 1 (aparece una vez)

#IDF("mesa") = log(3 / 3) = log(1) = 0

#TF-IDF("mesa", Documento 3) = 1 * 0 = 0

#Como se puede observar, el TF-IDF para la palabra "mesa" es 0 en todos los documentos porque aparece en todos los documentos del corpus y, por lo tanto, su IDF es 0. Esto significa que la palabra "mesa" no aporta mucha información discriminatoria en este caso. Mientras que las palabras como perro o gato pueden aportar más a la información.
#"""

import unicodedata #(unicodedata2 instalado)
import nltk #(instalado)

from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize
from nltk.stem import SnowballStemmer
from nltk.stem import WordNetLemmatizer
from sklearn.feature_extraction.text import TfidfVectorizer #(scikit-learn instalado)

#neecitamos algunos recursos que nos servirán para identificar simbolos o palabras conectoras
nltk.download('punkt')
nltk.download('stopwords')
nltk.download('wordnet')

#función que ahce un prepprocesamiento del texto según lo que nosotros necesitamos
def preprocess_text(text):
    #primero haremos tokens, usando la columna texto y dando a entender que hablamos del idioma español, esto lo reconoce por los recursos instalados arriba
    tokens = word_tokenize(text, language='spanish')

    #stopword se refiere a las palabras conectoras antes definidas, este pedazo de código se encarga de eliminar estas palabras que se identificaron en
    #el idioma español, además, se van a eliminar las palabras de longitud 1, que serían vocales y consonantes que no tienen más contenido
    stop_words = set(stopwords.words('spanish'))
    tokens = [word for word in tokens if word.lower() not in stop_words and len(word) > 1]

    #vamos a eliminar también palabras o símbolos especiales, como acentos, puntuación, etc, basándonos en el código ASCII
    clean_tokens = []
    for token in tokens:
        clean_token = re.sub(r'[^a-zA-ZÀ-ÿ]', ' ', token)
        clean_token = unicodedata.normalize('NFKD', clean_token).encode('ASCII', 'ignore').decode('utf-8', 'ignore')
        clean_tokens.append(clean_token)

    #esto ahce el proceso de lematización definido antes, el cual sí es complicado
    lemmatizer = WordNetLemmatizer()
    tokens = [lemmatizer.lemmatize(token) for token in clean_tokens]
    #Stemming mientras que la lematización reduce las palabras a una forma base, el stemming lo reduce a la raíz de la palabra
    #lo bueno que hay una base en python que sabe de esto, porque nosotros no sabemos ningún ejemplo xd
    stemmer = SnowballStemmer('spanish')
    tokens = [stemmer.stem(token) for token in tokens]

    #por último devolvemos los tokens
    return ' '.join(tokens)

#Aplicamos la función de preprocess text que se encarga de hacer un preprocesamiento a la columna de texto
df['text_preprocessed'] = df['text'].apply(preprocess_text)

# Vectorización de texto utilizando TF-IDF
#por último, vamos a hacer la vectorización de texto usando TF-IDF_ term Frequency-Inverse Document Frequency, el cual tiene en cuenta
#la aparición de una palabra en un documento y su importancia de la palabra en el corpus de documentos
vectorizer = TfidfVectorizer()
X = vectorizer.fit_transform(df['text_preprocessed'])

#Obtenemos los nombres de las características
feature_names = vectorizer.get_feature_names_out()

df.to_csv("CSV/Odioesptrabajado.csv",encoding="utf-8")
#"""## **3.-** Seleccionar un modelo de clasificación en base a diagramas de dispersión, curvas de distribución u otras técnicas

#Diagrama de dispersión:

#En nuestro caso, como tenemos una clasifiación multimodal, vamos a usar PCA para ver si se puede visualizar una separación clara entre las clases que tenemos.
#"""

import matplotlib.pyplot as plt
import seaborn as sns #(seaborn instalado)

from sklearn.decomposition import PCA
from sklearn.feature_extraction.text import TfidfVectorizer

vectorizer = TfidfVectorizer()
X = vectorizer.fit_transform(df['text_preprocessed'])

#Diagrama de dispersión utilizando PCA, done la x son las características de los textos ya después de la transformación
pca = PCA(n_components=2)
X_pca = pca.fit_transform(X.toarray())

plt.figure(figsize=(8, 6))
sns.scatterplot(x=X_pca[:, 0], y=X_pca[:, 1], hue=df['target'], palette='Set1')
plt.title('Diagrama de dispersión con PCA')
plt.xlabel('Componente Principal 1')
plt.ylabel('Componente Principal 2')
plt.legend(title='Target')
plt.show()

## Fuentes:

#Baggs, B. M. (2021, November 15). Online hate speech rose 20\% during pandemic: “We’ve normalised it.” Online Hate Speech Rose 20\% During Pandemic: “We’ve
#Normalised It.” https://www.bbc.com/news/newsbeat-59292509

#Discurso de odio”. (s.f.). En Wikipedia. Recuperado el 18 de abril de 2024 de https://es.wikipedia.org/wiki/Discurso_de_odio